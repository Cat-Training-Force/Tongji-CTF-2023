e = 191
p = 115454544015599150711525810879125485218158876863413904525004934220198757859356085118059908709057748261520507430434023140065098340351050254870943914108718470257154791297820228452801441913937900764632352422262383423576663832008718427558738772403390021363437566445995301950866790685622330139500896451192078274361
q = 172853206455421729776180172751124644903134249913948790535966034315036074203854054164604507127234846800687352458891000089040513423939825098230608319961771162233020977760025275862967322672515780852490807580220838608760264350985887420688113146642443706792083281947667852108402345005017868730472869424870810770009
n = p * q
c = 6482527759788796150573761737700507540864676337557774033420383838399732868161060051100057268613216107843440104079948558844131647119545373420642090497102526088868157544942613447595402347020466138409514766283578278817505123190722875423775755942170956109311132304140736806238742664306501422841757581515094847210524942575671641416940408987449919385489079834744631250120449901962187325764558234254163812940443536410477140165674485183311834485180344429646158755170808456964175542846981434549584895630565372825698723342613826984608739891795978296072318980983067877359219606495303313406943971293750517283829293478168501534409


def amm(delta, r, q):
    pho = 1
    while pow(pho, (q-1)//r, q) == 1:
        pho += 1
    t = 0
    s = q - 1
    while s % r == 0:
        s //= r
        t += 1
    alpha = 1
    while (s * alpha + 1) % r != 0:
        alpha += 1
    alpha = (s * alpha + 1) // r
    a = pow(pho, r**(t-1)*s, q)
    b = pow(delta, r*alpha-1, q)
    c = pow(pho, s, q)
    h = 1
    from sympy.ntheory import discrete_log
    for i in range(1, t-1):
        d = pow(b, r**(t-1-i), q)
        if d == 1:
            j = 0
        else:
            j = -discrete_log(q, d, a)
        b = (b * pow(c, r*j, q)) % q
        h = (h * pow(c, j, q)) % q
        c = pow(c, r, q)
    root = (h * pow(delta, alpha, q)) % q
    roots = set()
    for i in range(r):
        next_root = (root * pow(a, i, q)) % q
        assert pow(next_root, r, q) == delta % q
        roots.add(next_root)
    return roots


# e | p, e !| q
from Crypto.Util.number import inverse, long_to_bytes
from sympy.ntheory.modular import crt
m1s = amm(c, e, p)
m2 = pow(c, inverse(e, q-1), q)
for m1 in m1s:
    m = crt([p, q], [m1, m2])[0] % n
    flag = long_to_bytes(m)
    if b"tjctf" in flag:
        print(flag)
        break

